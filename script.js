const WORD_DATA = {
  "names": [
    "Ø¨Ø±ÛŒÙ†Ø¯Ø§Ø±",
    "Ø¨Û•Ø®ØªÛŒØ§Ø±",
    "Ø¨ÛŽØ³ØªÙˆÙˆÙ†",
    "Ú©Ø§Ù…Û•Ø±Ø§Ù†",
    "Ù†ÛŒØ´ØªÙ…Ø§Ù†",
    "Ø¨Û•Ø±Ø²Ø§Ù†",
    "Ø¨Û•Ù‡Û•Ø´Øª",
    "Ø³ÛŒØ±ÙˆØ§Ù†",
    "Ú©Ø§Ø±ÙˆØ§Ù†",
    "Ù‡Û•ÚµÙ…Û•Øª",
    "ÙˆØ´ÛŒØ§Ø±Ø§",
    "Ø¦Ø§Ø±Ø§Ø³",
    "Ø¦Ø§Ø²Ø§Ø¯",
    "Ø¦Ø§ÙˆØ§Ø²",
    "Ø¦Û•ÙˆÛŒÙ†",
    "Ø¨Ø§Ø±Ø§Ù†",
    "Ø¨Ø§ÙˆØ§Ù†",
    "Ø¨ÚµÛŽØ³Û•",
    "Ø¨Û•ÛŒØ§Ù†",
    "Ú†Û†Ù…Ø§Ù†",
    "Ø¯ÚµÙ†ÛŒØ§",
    "Ø¯ÛŒÙ„Ø§Ù†",
    "Ú•ÛŽØ¨ÛŒÙ†",
    "Ø³Ø§Ù…Ø§Ù†",
    "Ø³Û†Ø±Ø§Ù†",
    "Ø´ÛŽØ±Ú©Û†",
    "Ù…ÛŒØ¯ÛŒØ§",
    "Ù†Ø§Ø±ÛŒÙ†",
    "Ù‡Û•Ø±Ø¯ÛŒ",
    "Ù‡ÛŽÙ„ÛŒÙ†",
    "Ø¦Ø§ÚµØ§",
    "ØªØ§Ø±Ø§",
    "Ø¯Ø§Ù†Ø§",
    "Ø²Ø§Ù†Ø§",
    "Ú˜ÛŒØ§Ù†",
    "Ø³Ø§Ø±Ø§",
    "Ø´Ø§Ø¯ÛŒ",
    "Ø´ÙˆØ§Ù†",
    "Ø´ÛŒØ§Ùˆ",
    "Ú©Ø§Ù†ÛŒ",
    "Ú©Ø§ÙˆÛ•",
    "Ù„Ø§Ú¤Û•",
    "Ù„Ø§Ù†Û•",
    "Ù‡Û•ÚµÛ†",
    "Ù‡ÛŒÙˆØ§",
    "Ù‡ÛŽÚ¤ÛŒ"
  ],
  "animals": [
    "Ù¾Û•Ù¾ÙˆÙˆÙ„Û•",
    "Ú©Û•Ø±ÙˆÛŽØ´Ú©",
    "Ú©Û•ÚµÛ•Ø´ÛŽØ±",
    "Ù…ÛŽØ±ÙˆÙˆÙ„Û•",
    "Ù…ÛŽØ´ÙˆÙˆÙ„Û•",
    "Ø¨Ø§ÚµÙ†Ø¯Û•",
    "Ø¬ÙˆÙˆÚ†Ú©Û•",
    "Ú†Û†Ù„Û•Ú©Û•",
    "Ø²Û•Ú•Ø§ÙÛ•",
    "Ø³ÛŒØ³Ø±Ú©Û•",
    "Ù…Û•ÛŒÙ…ÙˆÙ†",
    "Ù†Û•Ù‡Û•Ù†Ú¯",
    "Ù¾Ø´ÛŒÙ„Û•",
    "Ø³ÛŒØ³Ø±Ú©",
    "Ù‚Ø±Ú˜Ø§Úµ",
    "Ú©ÛŒØ³Û•Úµ",
    "Ù…Ø±ÛŒØ´Ú©",
    "Ù‡ÛŽØ³ØªØ±",
    "Ø¦Ø§Ø³Ú©",
    "Ø¦Û•Ø³Ù¾",
    "Ù¾ÚµÙ†Ú¯",
    "ØªØ§ÙˆØ³",
    "Ú•ÛŽÙˆÛŒ",
    "Ú©Û†ØªØ±",
    "Ú¯ÙˆØ±Ú¯",
    "Ù…Ø§Ø³ÛŒ",
    "Ù…Ø§Ù…Ø²",
    "Ø´ÛŽØ±",
    "ÙÛŒÙ„",
    "Ù…Ø§Ø±"
  ],
  "food": [
    "Ù¾Ø§Ù‚Ù„Ø§ÙˆÛ•",
    "Ø¨Ø±ÛŒØ§Ù†ÛŒ",
    "Ù¾Û•ØªØ§ØªÛ•",
    "ØªÛ•Ù…Ø§ØªÛ•",
    "Ø´Û•Ø±Ø¨Û•Øª",
    "ÛŒØ§Ù¾Ø±Ø§Ø®",
    "Ø¨Û•Ú•ÙˆÙˆ",
    "Ø¨ÛŒØ¨Û•Ø±",
    "Ù¾Û•Ù†ÛŒØ±",
    "Ø¯Û†Ø´Ø§Ùˆ",
    "Ø¯Û†ÚµÙ…Û•",
    "Ø³Ø§ÙˆØ§Ø±",
    "Ø´Û†Ø±Ø¨Ø§",
    "Ú©Û•Ø¨Ø§Ø¨",
    "Ú¯ÛŽØ²Û•Ø±",
    "Ù„Û†Ø¨ÛŒØ§",
    "Ù‡ÛŽÙ„Ú©Û•",
    "Ø¨Ø±Ù†Ø¬",
    "Ù¾ÛŒØ§Ø²",
    "Ø´ÙØªÛ•",
    "Ù‚Ø§ÙˆÛ•",
    "Ù‚ÛŒÙ…Û•",
    "Ú©ÙØªÛ•",
    "Ú©Ù†Ú¯Ø±",
    "Ú©Û•Ø±Û•",
    "Ú¯Û†Ø´Øª",
    "Ù…Ø§Ø³Øª",
    "Ù†ÛŒØ³Ú©",
    "Ø³ÛŒØ±",
    "Ù†Ø§Ù†"
  ],
  "fruits": [
    "Ù„Ø§Ù„Û•Ù†Ú¯ÛŒ",
    "Ù‡Û•ÚµÙˆÙˆÚ˜Û•",
    "Ù‡Û•Ù†Ø¬ÛŒØ±",
    "Ø¨Ø§Ø¯Û•Ù…",
    "Ø®Û•ÛŒØ§Ø±",
    "Ø´ÙˆÙˆØªÛŒ",
    "Ù‚Û•ÛŒØ³ÛŒ",
    "Ú©Ø§ÚµÛ•Ú©",
    "Ú¯ÛŽÙ„Ø§Ø³",
    "Ù†Ø§Ø±Ù†Ø¬",
    "Ù‡Û•Ø±Ù…ÛŽ",
    "Ù‡Û•Ù†Ø§Ø±",
    "Ø³Ù†Ø¯ÛŒ",
    "Ø´Ù„ÛŒÚ©",
    "Ú©ÛŒÙˆÛŒ",
    "Ú¯ÙˆÛŽØ²",
    "Ù„ÛŒÙ…Û†",
    "ØªØ±ÛŽ",
    "Ø³ÛŽÙˆ",
    "Ù…Û†Ø²"
  ],
  "cities": [
    "Ù¾ÛŽÙ†Ø¬ÙˆÛŽÙ†",
    "Ø­Ø§Ø¬ÛŒØ§ÙˆØ§",
    "Ø®Ø§Ù†Û•Ù‚ÛŒÙ†",
    "Ø®Û•Ù„ÛŒÙØ§Ù†",
    "Ú•Û•ÙˆØ§Ù†Ø¯Ø²",
    "Ø³Ù„ÛŽÙ…Ø§Ù†ÛŒ",
    "Ø³ÛŒØ¯Ø³Ø§Ø¯Ù‚",
    "Ø³ÛŒØ¯Û•Ú©Ø§Ù†",
    "Ø´Û•Ù‚ÚµØ§ÙˆÛ•",
    "Ù‚Û•ÚµØ§Ø¯Ø²ÛŽ",
    "Ú©Û•Ø±Ú©ÙˆÙˆÚ©",
    "Ù‡Û•ÚµÛ•Ø¨Ø¬Û•",
    "Ø¦Ø§Ù…ÛŽØ¯ÛŒ",
    "Ù¾ÛŒØ±Ù…Ø§Ù…",
    "Ø¯ÙˆÙˆÚ©Ø§Ù†",
    "Ø¹Û•Ø±Ø¨Û•Øª",
    "Ù‡Û•ÙˆÙ„ÛŽØ±",
    "Ø¦Ø§Ú©Ø±ÛŽ",
    "Ø¦Ø§Ù…ÛŽØ¯",
    "Ø¨Ø§Ù†ÛŒÛŽ",
    "Ú•Ø§Ù†ÛŒÛ•",
    "Ø³Û†Ø±Ø§Ù†",
    "Ú©Û•Ù„Ø§Ø±",
    "Ù„Û†Ù„Ø§Ù†",
    "Ø¯Ù‡Û†Ú©",
    "Ø²Ø§Ø®Û†",
    "Ø³Ù…ÛŽÚµ",
    "Ø´ÙˆØ§Ù†",
    "Ú©ÙØ±ÛŒ",
    "Ú©Û†ÛŒÛ•"
  ],
  "countries": [
    "Ø¦Û•Ù…Ø±ÛŒÚ©Ø§",
    "Ø¦ÛŒØªØ§Ù„ÛŒØ§",
    "Ø¨Û•Ú•Ø§Ø²ÛŒÙ„",
    "Ø¨Û•Ù„Ø¬ÛŒÚ©Ø§",
    "Ù¾Û†ÚµÛ•Ù†Ø¯Ø§",
    "ØªØ§ÛŒÙ„Û•Ù†Ø¯",
    "Ø¬Û•Ø²Ø§Ø¦ÛŒØ±",
    "Ø³ÙˆØ±ÛŒÙ†Ø§Ù…",
    "ÙÛ•Ú•Û•Ù†Ø³Ø§",
    "Ú¤Ø§ØªÛŒÚ©Ø§Ù†",
    "Ù…Ø§Ù„ÛŒØ²ÛŒØ§",
    "Ù‡Û†ÚµÛ•Ù†Ø¯Ø§",
    "Ø¦Ø§ÚµÙ…Ø§Ù†",
    "Ø¦Û†Ø±Ø¯Û†Ù†",
    "Ø¨Û•Ø­Ø±ÛŽÙ†",
    "Ø¨ÛŽÙ„Ú˜ÛŒÚ©",
    "Ù¾Û•Ù†Û•Ù…Ø§",
    "ØªØ§ÛŒÙˆØ§Ù†",
    "ØªÙˆØ±Ú©ÛŒØ§",
    "Ø¬Û†Ø±Ø¬ÛŒØ§",
    "Ú•ÙˆÙˆØ³ÛŒØ§",
    "Ø³Ø¹ÙˆØ¯ÛŒÛ•",
    "Ø³ÙˆÙˆØ¯Ø§Ù†",
    "Ø³ÙˆÛŒØ³Ø±Ø§",
    "ÙÙ„ÛŒÙ¾ÛŒÙ†",
    "Ú¤ÛŽØªÙ†Ø§Ù…",
    "Ú©Û•Ù†Û•Ø¯Ø§",
    "Ù„ÙˆØ¨Ù†Ø§Ù†",
    "Ù…Û•ØºØ±ÛŒØ¨",
    "Ù…Û•Ú©Ø³ÛŒÚ©",
    "Ù…Û†Ù†Ø§Ú©Û†",
    "Ù†Û•Ø±ÙˆÛŒØ¬",
    "Ø¦ÙˆØ±Ø¯Ù†",
    "Ø¦ÛŽØ±Ø§Ù†",
    "Ú˜Ø§Ù¾Û†Ù†",
    "Ø³ÙˆØ±ÛŒØ§",
    "Ø³Û†Ù…Ø§Úµ",
    "Ø¹ÙˆÙ…Ø§Ù†",
    "Ø¹ÛŽØ±Ø§Ù‚",
    "Ù‚Û•ØªÛ•Ø±",
    "Ù‚ÙˆØ¨Ø±Ø³",
    "Ú©ÛŒÙ†ÛŒØ§",
    "Ù„ÛŒØ¨ÛŒØ§",
    "Ù†Û•Ù…Ø³Ø§",
    "ÛŒÛ•Ù…Û•Ù†",
    "ÛŒÛ†Ù†Ø§Ù†",
    "ØªÙˆÙ†Ø³",
    "Ø³ÙˆÛŒØ¯",
    "ØºØ§Ù†Ø§",
    "Ú©ÙˆØ¨Ø§",
    "Ú©ÙˆÛŽØª",
    "Ù…Ø§Ù„ÛŒ",
    "Ù…ÛŒØ³Ø±",
    "ÙˆÛŽÚµØ²",
    "Ú†ÛŒÙ†"
  ],
  "nature": [
    "Ø¦Û•Ø³ØªÛŽØ±Û•",
    "Ø³Û•ÙˆØ²Ø§ÛŒÛŒ",
    "Ø¦Ø§Ø³Ù…Ø§Ù†",
    "Ú•ÙˆÙˆØ¨Ø§Ø±",
    "Ø¨Ø§Ø±Ø§Ù†",
    "Ø¨Û•Ù‡Ø§Ø±",
    "Ù¾Ø§ÛŒÛŒØ²",
    "Ø¯Û•Ø±ÛŒØ§",
    "Ø²Ø³ØªØ§Ù†",
    "Ù‡Ø§ÙˆÛŒÙ†",
    "Ø¨Û•ÙØ±",
    "Ù…Ø§Ù†Ú¯",
    "ÙˆÛ•Ø±Ø²",
    "Ø®Û†Ø±",
    "Ø¯Ø§Ø±",
    "Ø´Ø§Ø®",
    "Ú¯ÙˆÚµ"
  ],
  "body_parts": [
    "Ù¾Û•Ù†Ø¬Û•",
    "Ø¯Ø¯Ø§Ù†",
    "Ø¯Û•Ø³Øª",
    "Ø²Ù…Ø§Ù†",
    "Ù„ÙˆÙˆØª",
    "Ú†Ø§Ùˆ",
    "Ø³Û•Ø±",
    "Ø´Ø§Ù†",
    "Ù‚Ø§Ú†",
    "Ú¯ÙˆÛŽ",
    "Ù„ÛŽÙˆ",
    "Ù…ÙˆÙˆ"
  ],
  "household": [
    "Ù¾Û•Ù†Ø¬Û•Ø±Û•",
    "Ù¾Û•Ø±Ø¯Ø§Ø®",
    "Ø³Û•Ù„Ø§Ø¬Û•",
    "Ø®Ø§ÙˆÙ„ÛŒ",
    "Ø¯Û•Ø±Ú¯Ø§",
    "Ø¯Û†Ø´Û•Ú©",
    "Ú©Û•ÙˆÚ†Ú©",
    "Ú©ÙˆØ±Ø³ÛŒ",
    "Ø¨Û•Ú•Û•",
    "Ú†Û•Ù‚Û†",
    "Ø³Û†Ù¾Ø§",
    "Ù‚Ø§Ù¾",
    "Ù…ÛŽØ²"
  ],
  "professions": [
    "Ø¨Ø§Ø²Ø±Ú¯Ø§Ù†",
    "Ù¾Ø§Ø±ÛŽØ²Û•Ø±",
    "Ú©Ø§Ø±Ù…Û•Ù†Ø¯",
    "Ù…Ø§Ù…Û†Ø³ØªØ§",
    "Ø¬ÙˆØªÛŒØ§Ø±",
    "Ø¯Ø§Ø±ØªØ§Ø´",
    "Ù†ÙˆÙˆØ³Û•Ø±",
    "ÙˆÛŽÙ†Û•Ú¯Ø±",
    "Ù¾Ø²ÛŒØ´Ú©",
    "Ù¾Û†Ù„ÛŒØ³",
    "Ø´Û†ÙÛŽØ±",
    "ÙˆÛ•Ø³ØªØ§"
  ],
  "colors": [
    "Ø²Û•ÛŒØªÙˆÙ†ÛŒ",
    "Ù¾Û•Ù…Û•ÛŒÛŒ",
    "Ú•Û•Ø³Ø§Ø³ÛŒ",
    "Ù‚Ø§ÙˆÛ•ÛŒÛŒ",
    "Ø²Û•Ø±Ø¯",
    "Ø³Û•ÙˆØ²",
    "Ø³ÙˆÙˆØ±",
    "Ù†ÛŒÙ„ÛŒ",
    "Ú•Û•Ø´",
    "Ø³Ù¾ÛŒ",
    "Ø´ÛŒÙ†",
    "Ù…Û†Ø±"
  ]
};

const NUMBER_OF_GUESSES = 6;
let WORD_LENGTH = 5; // Default, will change
let currentGuess = 0;
let currentTile = 0;
let secretWord = "";
let guesses = [[]];
let isGameOver = false;
let validWords = [];

const board = document.getElementById('board');
const startScreen = document.getElementById('start-screen');
const gameUI = document.getElementById('game-ui');
const gameInput = document.getElementById('game-input');
const startBtn = document.getElementById('start-game-btn');
const endGameActions = document.getElementById('end-game-actions');
const playAgainBtn = document.getElementById('play-again-btn');
const goToMenuBtn = document.getElementById('go-to-menu-btn');

// Start Game Listener
// Start Game Listener
startBtn.addEventListener('click', startGame);
playAgainBtn.addEventListener('click', playAgain);
goToMenuBtn.addEventListener('click', resetToMenu);

// Custom Dropdown Logic
function initCustomDropdown() {
  const wrapper = document.querySelector('.custom-select-wrapper');
  const select = wrapper.querySelector('.custom-select');
  const trigger = wrapper.querySelector('.custom-select-trigger');
  const options = wrapper.querySelectorAll('.custom-option');
  const hiddenInput = document.getElementById('category-select');
  const triggerText = document.getElementById('trigger-text');

  // Toggle open
  trigger.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent document click from closing immediately
    select.classList.toggle('open');
  });

  // Option select
  options.forEach(option => {
    option.addEventListener('click', () => {
      // Update hidden input
      hiddenInput.value = option.dataset.value;

      // Update trigger text
      triggerText.textContent = option.textContent;

      // Update selected class
      options.forEach(opt => opt.classList.remove('selected'));
      option.classList.add('selected');

      // Close dropdown
      select.classList.remove('open');
    });
  });

  // Click outside to close
  document.addEventListener('click', (e) => {
    if (!wrapper.contains(e.target)) {
      select.classList.remove('open');
    }
  });
}

// Initialize Dropdown
initCustomDropdown();


function getSecretWord(words) {
  const allowedLengths = [3, 4, 5, 6, 7];
  // Filter words that match allowed lengths
  const candidates = words.filter(w => allowedLengths.includes(w.length));

  // If no words match (fallback), just return random from original list
  if (candidates.length === 0) {
    return words[Math.floor(Math.random() * words.length)];
  }

  // 1. Identify which lengths exist in the candidates
  const availableLengths = [...new Set(candidates.map(w => w.length))];

  // 2. Pick a random length from the available ones
  const chosenLength = availableLengths[Math.floor(Math.random() * availableLengths.length)];

  // 3. Filter candidates to only that length
  const specificLengthWords = candidates.filter(w => w.length === chosenLength);

  // 4. Pick a random word from that filtered list
  return specificLengthWords[Math.floor(Math.random() * specificLengthWords.length)];
}

function startGame() {
  const category = document.getElementById('category-select').value;

  // Get all words in category
  let allCategoryWords;
  if (category === 'mix') {
    allCategoryWords = Object.values(WORD_DATA).flat();
  } else {
    allCategoryWords = WORD_DATA[category];
  }

  if (!allCategoryWords || allCategoryWords.length === 0) {
    alert("Ù‡ÛŒÚ† ÙˆØ´Û•ÛŒÛ•Ú© Ù†Û•Ø¯Û†Ø²Ø±Ø§ÛŒÛ•ÙˆÛ• Ø¨Û† Ø¦Û•Ù… Ø¨Û•Ø´Û•.");
    return;
  }

  // Pick a random word using the new logic (random length 4-7 first)
  secretWord = getSecretWord(allCategoryWords);
  WORD_LENGTH = secretWord.length;

  // Store validWords as all words of the SAME length for potential future valid list checks
  validWords = allCategoryWords.filter(w => w.length === WORD_LENGTH);

  guesses = [[]];
  currentGuess = 0;
  currentTile = 0;
  isGameOver = false;

  // Update UI
  startScreen.classList.remove('active');
  startScreen.classList.add('hidden');
  gameUI.classList.remove('hidden');
  gameUI.classList.add('active'); // Ensure flex display

  // Set Category Display
  const categoryLabel = document.querySelector(`.custom-option[data-value="${category}"]`).textContent;
  document.getElementById('current-category').textContent = categoryLabel.split('(')[0].trim();

  // Update Input MaxLength
  gameInput.maxLength = WORD_LENGTH + 1; // +1 for the dummy space
  gameInput.value = " "; // Dummy space
  gameInput.focus();

  endGameActions.classList.add('hidden');
  initBoard();
}

function playAgain() {
  // Re-pick from the whole current category list (stored in WORD_DATA)
  // We need to know which category was selected
  const category = document.getElementById('category-select').value;
  let allCategoryWords;
  if (category === 'mix') {
    allCategoryWords = Object.values(WORD_DATA).flat();
  } else {
    allCategoryWords = WORD_DATA[category];
  }

  secretWord = getSecretWord(allCategoryWords);
  WORD_LENGTH = secretWord.length;
  validWords = allCategoryWords.filter(w => w.length === WORD_LENGTH);

  guesses = [[]];
  currentGuess = 0;
  currentTile = 0;
  isGameOver = false;

  gameInput.maxLength = WORD_LENGTH + 1; // +1 for the dummy space
  gameInput.value = " "; // Dummy space
  gameInput.focus();
  endGameActions.classList.add('hidden');

  initBoard();
}

function initBoard() {
  board.innerHTML = ''; // Clear previous
  // Update grid columns CSS variable
  document.documentElement.style.setProperty('--cols', WORD_LENGTH);

  for (let i = 0; i < NUMBER_OF_GUESSES; i++) {
    const row = document.createElement('div');
    row.className = 'row';
    for (let j = 0; j < WORD_LENGTH; j++) {
      const tile = document.createElement('div');
      tile.className = 'tile';
      row.appendChild(tile);
    }
    board.appendChild(row);
  }
}

// Native Input Logic
// Keep focus on input for mobile
document.addEventListener('click', (e) => {
  // Only text inputs or board clicks should focus
  if (!isGameOver && gameUI.classList.contains('active')) {
    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT' && e.target.tagName !== 'BUTTON') {
      gameInput.focus();
    }
  }
});
document.addEventListener('touchstart', (e) => {
  if (!isGameOver && gameUI.classList.contains('active')) {
    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT' && e.target.tagName !== 'BUTTON') {
      gameInput.focus();
    }
  }
});

// Sync input value with game state
gameInput.addEventListener('input', (e) => {
  if (isGameOver) return;

  const val = gameInput.value;

  // Handle Backspace (input is empty)
  if (val.length === 0) {
    deleteLetter();
    gameInput.value = " ";
    return;
  }

  // Handle Addition (length > 1)
  if (val.length > 1) {
    const char = val.charAt(1);
    // Regex for Kurdish/Arabic chars
    if (/^[\u0600-\u06FF\u0750-\u077F]$/.test(char)) {
      addLetter(char);
    }
    gameInput.value = " ";
  }
});

// Handle keys (Enter) reliably via keydown
gameInput.addEventListener('keydown', (e) => {
  if (isGameOver) return;

  if (e.key === 'Enter') {
    checkGuess();
    e.preventDefault();
  }
});

function addLetter(letter) {
  if (currentTile < WORD_LENGTH && guesses[currentGuess].length < WORD_LENGTH) {
    guesses[currentGuess].push(letter);

    const row = board.children[currentGuess];
    const tile = row.children[currentTile];
    tile.textContent = letter;
    tile.setAttribute('data-state', 'active');

    tile.classList.add('bounce');
    tile.addEventListener('animationend', () => {
      tile.classList.remove('bounce');
    }, { once: true });

    currentTile++;
  }
}

function deleteLetter() {
  if (currentTile > 0) {
    guesses[currentGuess].pop();
    currentTile--;

    const row = board.children[currentGuess];
    const tile = row.children[currentTile];
    tile.textContent = '';
    tile.setAttribute('data-state', 'empty');
  }
}

function checkGuess() {
  const guessWord = guesses[currentGuess];
  const row = board.children[currentGuess];

  if (guessWord.length !== WORD_LENGTH) {
    showMessage(`ØªÚ©Ø§ÛŒÛ• ${WORD_LENGTH} Ù¾ÛŒØª Ø¨Ù†ÙˆÙˆØ³Û•`);
    row.classList.add('shake');
    row.addEventListener('animationend', () => {
      row.classList.remove('shake');
    }, { once: true });
    return;
  }

  const guessString = guessWord.join('');

  // Check if word exists in valid list? Maybe optional strict mode.
  // For now, allow any combo.

  const secretWordChars = secretWord.split('');
  const guessChars = [...guessWord];

  for (let i = 0; i < WORD_LENGTH; i++) {
    if (guessChars[i] === secretWordChars[i]) {
      row.children[i].setAttribute('data-state', 'correct');
      guessChars[i] = null;
      secretWordChars[i] = null;
    }
  }

  for (let i = 0; i < WORD_LENGTH; i++) {
    if (guessChars[i]) {
      const indexInSecret = secretWordChars.indexOf(guessChars[i]);
      if (indexInSecret > -1) {
        row.children[i].setAttribute('data-state', 'present');
        secretWordChars[indexInSecret] = null;
      } else {
        row.children[i].setAttribute('data-state', 'absent');
      }
    }
    row.children[i].classList.add('flip');
  }

  if (guessString === secretWord) {
    showMessage("Ù¾ÛŒØ±Û†Ø²Û•! Ø¨Ø±Ø¯ØªÛ•ÙˆÛ• ðŸ‘");
    isGameOver = true;
    gameInput.blur();
    setTimeout(() => endGameActions.classList.remove('hidden'), 500);
  } else {
    if (currentGuess === NUMBER_OF_GUESSES - 1) {
      showMessage("Ø¯Û†Ú•Ø§ÛŒØª! ÙˆØ´Û•Ú©Û• Ø¨Ø±ÛŒØªÛŒ Ø¨ÙˆÙˆ Ù„Û•: " + secretWord);
      isGameOver = true;
      gameInput.blur();
      setTimeout(() => endGameActions.classList.remove('hidden'), 500);
    } else {
      currentGuess++;
      currentTile = 0;
      guesses.push([]);
    }
  }
}

function showMessage(msg) {
  const container = document.getElementById('message-container');
  const el = document.createElement('div');
  el.textContent = msg;
  el.style.backgroundColor = '#fff';
  el.style.color = '#000';
  el.style.padding = '10px 20px';
  el.style.borderRadius = '4px';
  el.style.position = 'absolute';
  el.style.top = '10%';
  el.style.left = '50%';
  el.style.transform = 'translate(-50%, 0)';
  el.style.zIndex = '2000';

  container.appendChild(el);
  setTimeout(() => {
    if (container.contains(el)) container.removeChild(el);
  }, 2500);
}

// Restart Game Logic
const restartBtn = document.getElementById("restart-btn");

restartBtn.addEventListener("click", resetToMenu);

function resetToMenu() {
  // Go back to start screen to choose new settings?
  // Or restart with same settings?
  // Let's restart with same settings if within active game
  // But honestly, going back to menu is more flexible.

  isGameOver = false;
  startScreen.classList.remove('hidden');
  startScreen.classList.add('active');
  gameUI.classList.remove('active');
  gameUI.classList.add('hidden');
  endGameActions.classList.add('hidden');
}

// Help Modal Logic
const modal = document.getElementById("help-modal");
const btn = document.getElementById("help-btn");
const span = document.getElementsByClassName("close-btn")[0];

btn.onclick = function () {
  modal.style.display = "block";
}
span.onclick = function () {
  modal.style.display = "none";
}
window.onclick = function (event) {
  if (event.target == modal) {
    modal.style.display = "none";
  }
}
